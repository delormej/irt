/*
This software is subject to the license described in the License.txt file 
included with this software distribution. You may not use this file except in compliance 
with this license.

Copyright (c) Dynastream Innovations Inc. 2012
All rights reserved.
*/


#pragma once
#include "StdAfx.h"
#include "LEVSensor.h"


/**************************************************************************
* LEVSensor::ANT_eventNotification
* 
* Process ANT channel event
*
* ucEventCode_: code of ANT channel event
* pucEventBuffer_: pointer to buffer containing data received from ANT,
*		or a pointer to the transmit buffer in the case of an EVENT_TX
* 
* returns: N/A
*
**************************************************************************/
void LEVSensor::ANT_eventNotification(UCHAR ucEventCode_, UCHAR* pucEventBuffer_)
{
	switch(ucEventCode_)
	{
	case EVENT_TX:
		HandleTransmit((UCHAR*) pucEventBuffer_);
		UpdateDisplay();
		break;

	case EVENT_RX_ACKNOWLEDGED: // for receiving page 16 commands
	case EVENT_RX_BURST_PACKET: // intentional fall thru
	case EVENT_RX_BROADCAST:	// for receiving common pages broadcast
		HandleReceive((UCHAR*) pucEventBuffer_);	
		break;

	/*case EVENT_TRANSFER_TX_COMPLETED:	// For sending ACK request replies
		ucAckRetryCount = 0;			// Reset retransmission counter
		ucMsgExpectingAck = 0;			// Clear pending msg code		
		break;

	case EVENT_TRANSFER_TX_FAILED:	
	case EVENT_ACK_TIMEOUT:				// Intentional fall thru
		if(ucMsgExpectingAck)
			HandleRetransmit();			// resend if it failed
		break;*/

	default:
		break;
	}
}


/**************************************************************************
 * LEVSensor::InitializeSim
 * 
 * Initializes simulator variables
 * 
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::InitializeSim()
{	
	ulTimerInterval = 250;      // in ms - simulates the sensor sending the most relevant information every message period
	dbDispAcumDist = 0;
	bPage16Supported = TRUE;	// default to support this page, matching UI

	ucRequestPage = 1;	 // the page to transmit
	ucRequestCount = 1; // the number of times to re-transmit
	bTxRequestFlag = FALSE;	
	bTxPage34 = FALSE;

	// required common pages
	commonDataSensor->ulSerialNum = System::Convert::ToUInt32(this->textBox_SerialNum->Text);
	commonDataSensor->ucSwVersion = System::Convert::ToByte(this->textBox_SwVersion->Text);
	commonDataSensor->ucHwVersion = System::Convert::ToByte(this->textBox_HwVersion->Text);
	commonDataSensor->usMfgID = System::Convert::ToUInt16(this->textBox_MfgID->Text);
	commonDataSensor->usModelNum = System::Convert::ToUInt16(this->textBox_ModelNum->Text);

	// Initialize variables to match the UI
	LEVData->ucSupportedTravelModes = System::Convert::ToByte(this->numericUpDown_P5RegenModes->Value);
	LEVData->ucSupportedTravelModes = (LEVData->ucSupportedTravelModes | (System::Convert::ToByte(this->numericUpDwn_P5AssistModes->Value) << 3));
	LEVData->usCurrentLEVSpeed = System::Convert::ToUInt16(this->numericUpDown_P2Speed->Value * 10); 
	LEVData->usCurrentLEVSpeed |= 0xF000;
	LEVData->usSpeed = System::Convert::ToUInt16(this->numericUpDown_P2Speed->Value * 10);
	LEVData->usSpeed |= 0xF000;
	//LEVData->ucTravelModeState = 0  (Off is already default)
	//LEVData->ucSystemState = 0 (UI is all off / 0)
	//LEVData->ucGearState = 0 (UI is all off / 0)
	//LEVData->ucErrorMessage = 0 (UI defaults to 0)
	//LEVData->ucTemperature = 0 (UI defaults to 0)
	LEVData->ucPercentAssist = (System::Convert::ToByte(this->numericUpDown_P3PercentAssist->Value)); 
	LEVData->ucBatteryCharge = (System::Convert::ToByte(this->numericUpDown_P3Charge->Value)); 
	LEVData->ucBatteryVoltage = (System::Convert::ToByte(this->numericUpDown_P4Voltage->Value)); 
	LEVData->usRemainingRange = (System::Convert::ToUInt16(this->numericUpDown_P2Range->Value)); 
	LEVData->usRemainingRange |= 0xF000;
	LEVData->usChargeCycleCount = System::Convert::ToUInt16(this->numericUpDown_P4ChargeCycle->Value); 
	LEVData->usFuelConsumption = System::Convert::ToUInt16(this->numericUpDown_P4FuelConsumption->Value * 10); 
	LEVData->usP34FuelConsumption = System::Convert::ToUInt16(this->numericUpDown_P4FuelConsumption->Value * 10);
	LEVData->usDistanceOnCharge = System::Convert::ToUInt16(this->numericUpDown_P4DistanceOnCharge->Value * 10);
	LEVData->usWheelCircumference = System::Convert::ToUInt16(this->numericUpDown_P5Circum->Value); 
	LEVData->usWheelCircumference |= 0xF000;
	//LEVData->ulOdometer = 0 (UI defaults to 0)
}


/**************************************************************************
 * LEVSensor::HandleTransmit
 * 
 * Encode data generated by simulator for transmission
 *
 * pucTxBuffer_: pointer to the transmit buffer
 * 
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::HandleTransmit(UCHAR* pucTxBuffer_)
{
	static ULONG ulMessageCount = 1;	
	static UCHAR ucLevPatternCount = 0;
	static UCHAR ucReqCommonPatternCount = 0;
	static UCHAR ucLevSlot4Count = 0;
	static UCHAR ucLevSlot2Count = 0;
	
	UCHAR aucLevTxPattern[4] = {LEVData->PAGE1_SPEED_SYSTEM1,LEVData->PAGE2_SPEED_DISTANCE,LEVData->PAGE3_SPEED_SYSTEM2,LEVData->PAGE4_BATTERY};  // this is the required pattern
	UCHAR aucReqCommonTxPattern[2] = {commonDataSensor->PAGE80, commonDataSensor->PAGE81};	 // defines the order of the common pages every 20 msgs
	UCHAR aucLevSlot4TxPatter[2] = {LEVData->PAGE4_BATTERY, LEVData->PAGE5_CAPABILITES};	 // defines an alternating, P4, P5 pattern for slot 4				
	UCHAR aucLevSlot2TxPattern[2] = {LEVData->PAGE2_SPEED_DISTANCE, LEVData->PAGE34_SPEED_DISTANCE}; //defines an alternating, P2, P34 page rotiation for slot 2 (if page 34 requested)

	// Request pages only on request. This takes priority over all other messages.
	if (bTxRequestFlag == TRUE)   
	{
		LEVData->EncodeData(ucRequestPage, pucTxBuffer_);

		ucRequestCount--;		   // subtract one from the resend count
		if (ucRequestCount == 0)   // if count is zero, then reset 
		{
			bTxRequestFlag = FALSE;

			//also restart the LEV pattern back at page 1
			ucLevPatternCount = 0; 
			ulMessageCount = 1;     
		}

		ulMessageCount++;  // keep incrementing this
		return;			   // skip the rest of the function in this case
	}	
	
	// send LEV data pages
	switch (aucLevTxPattern[ucLevPatternCount])
	{
		case LEVData->PAGE1_SPEED_SYSTEM1:
			LEVData->EncodeData(LEVData->PAGE1_SPEED_SYSTEM1, pucTxBuffer_);
			break;

		case LEVData->PAGE2_SPEED_DISTANCE:
			if(bTxPage34)
			{
				LEVData->EncodeData(aucLevSlot2TxPattern[ucLevSlot2Count], pucTxBuffer_);
				ucLevSlot2Count++;
				
				if(ucLevSlot2Count >=2)
					ucLevSlot2Count = 0;
			}
			else
				LEVData->EncodeData(LEVData->PAGE2_SPEED_DISTANCE, pucTxBuffer_);
			break;

		case LEVData->PAGE3_SPEED_SYSTEM2:
			LEVData->EncodeData(LEVData->PAGE3_SPEED_SYSTEM2, pucTxBuffer_);
			break;

		case LEVData->PAGE4_BATTERY:
			if (ulMessageCount >= 20)
			{
				ulMessageCount = 1;     // reset count
				// send common data pages 80 and 81
				commonDataSensor->Encode(aucReqCommonTxPattern[ucReqCommonPatternCount], pucTxBuffer_);
				ucReqCommonPatternCount++;

				if (ucReqCommonPatternCount >= 2)
					ucReqCommonPatternCount = 0;
			}
			else
			{
				LEVData->EncodeData(aucLevSlot4TxPatter[ucLevSlot4Count], pucTxBuffer_);
				ucLevSlot4Count++;

				if (ucLevSlot4Count >= 2)
					ucLevSlot4Count = 0;
			}
			break;

		default:
			break;
	}
	
	ucLevPatternCount++;

	if (ucLevPatternCount >= 4)
		ucLevPatternCount = 0;  // reset the message count at the end

	ulMessageCount++;
}


/**************************************************************************
 * LEVSensor::HandleReceive
 * 
 * Decode incoming transmissions, specifically data requests
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::HandleReceive(UCHAR* pucRxBuffer_)
{
	UCHAR ucPageNum = pucRxBuffer_[0];

	switch(ucPageNum)
	{
		case LEVData->PAGE16_DISPLAY_DATA:
		{
			// only process if supported
			if (bPage16Supported == TRUE)
			{
				// decode P16, loading the P16 variables
				LEVData->Decode(pucRxBuffer_);
				
				// now we need to decode that into the Page 1 and Page 2 variables to "set" these paramaters
				if (LEVData->ucP16TravelMode != 0xFF)// if not set to "not supported"
				{
					MapAssistModes();
					MapRegenModes();
				}
				// bits 0-5 of P1 gear state match up to bits 4-9 of the P16 command
				LEVData->ucGearState = (LEVData->ucGearState & 0xC0);	 // clear bits 0-5 of current value
				LEVData->ucGearState = LEVData->ucGearState | ((LEVData->usP16DisplayCommand & 0x03F0) >> 4);  // clear everything but bits 4-9 and shift down
				
				// bits 0-3 of P1 system state match up to bits 0-3 of the P16 command
				LEVData->ucSystemState = (LEVData->ucSystemState & 0xF0);	 // clear bits 0-3 of current value
				LEVData->ucSystemState = LEVData->ucSystemState | (LEVData->usP16DisplayCommand & 0x000F);	   // clear everything but bits 0-3 
				
				// *** DO UI HERE? or move out?
				
				
				// clear everything but bits 3-5, then shift down to get current assist level
				this->comboBox_P1AssistLevel->SelectedIndex = ((LEVData->ucTravelModeState & 0x38) >> 3);
				// clear everything but bits 0-2 to get current regen level
				this->comboBox_P1RegenLevel->SelectedIndex = (LEVData->ucTravelModeState & 0x07);

				// clear everything but bits 2-5, then shift down to get rear gear setting
				this->comboBox_P1FrontGear->SelectedIndex = (LEVData->ucGearState & 0x03); 
				// clear everything but bits 0-1 to get front gear setting
				this->comboBox_P1RearGear->SelectedIndex = ((LEVData->ucGearState & 0x3C) >> 2);
				
				if ((LEVData->ucSystemState & 0x04) != 0)
					this->checkBox_P1HighBeam->Checked = TRUE;
				else
					this->checkBox_P1HighBeam->Checked = FALSE;

				if ((LEVData->ucSystemState & 0x08) != 0)
					this->checkBox_P1LightOn->Checked = TRUE;
				else
					this->checkBox_P1LightOn->Checked = FALSE;

				if ((LEVData->ucSystemState & 0x02) != 0)
					this->checkBox_P1LeftSignalOn->Checked = TRUE;
				else
					this->checkBox_P1LeftSignalOn->Checked = FALSE;

				if ((LEVData->ucSystemState & 0x01) != 0)
					this->checkBox_P1RightSignalOn->Checked = TRUE;
				else
					this->checkBox_P1RightSignalOn->Checked = FALSE;
				
				
				// manufacturer ID
				this->label_P16ManIDValue->Text = LEVData->usP16ManID.ToString();

				// wheel circumference
				if ((LEVData->usP16WheelCircum > 1) && (LEVData->usP16WheelCircum  < 4096) && !(this->checkBox_P5WheelCircum->Checked))
					this->numericUpDown_P5Circum->Value = LEVData->usP16WheelCircum;
			}	
			break;
		}
		case LEVData->PAGE70_REQUEST:
		{
			ucRequestPage = pucRxBuffer_[6];	 // save the page to transmit
			ucRequestCount = pucRxBuffer_[5];	 // save the number of times to re-transmit
			bTxRequestFlag = TRUE;				 // flag to tell the tx function to send the requested page
			break;
		}
		case commonDataDisplay->PAGE80:
		{
			commonDataDisplay->Decode(pucRxBuffer_);
			this->label_Glb_ManfIDDisplay->Text = commonDataDisplay->usMfgID.ToString();
			this->label_Glb_HardwareVerDisplay->Text = commonDataDisplay->ucHwVersion.ToString();
			this->label_Glb_ModelNumDisplay->Text = commonDataDisplay->usModelNum.ToString();
			break;
		}
		case commonDataDisplay->PAGE81:
		{
			commonDataDisplay->Decode(pucRxBuffer_);
			if(commonDataDisplay->ulSerialNum == 0xFFFFFFFF)
				this->label_Glb_SerialNumDisplay->Text = "N/A";
			else
				this->label_Glb_SerialNumDisplay->Text = commonDataDisplay->ulSerialNum.ToString();
			this->label_Glb_SoftwareVerDisplay->Text = commonDataDisplay->ucSwVersion.ToString();
			break;
		}
	}

}


/**************************************************************************
 * LEVSensor::onTimerTock
 * 
 * Simulates a sensor event, updating simulator data based on this event
 * Modifications to the timer interval are applied immediately after this
 * at ANTChannel
 *
 * usEventTime_: current time (ms)
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::onTimerTock(USHORT eventTime_)
{	
	USHORT usCurrentSpeed = LEVData->usCurrentLEVSpeed & 0x0FFF;
	dbDispAcumDist += (double) (usCurrentSpeed * ulTimerInterval) / 36000000;  
	if (dbDispAcumDist > 167772)  // check for rollover
		dbDispAcumDist = 0;

	// distance is transmitted in 0.01 km intervals
	LEVData->ulOdometer = System::Convert::ToUInt32(dbDispAcumDist * 100);
	LEVData->ulP34Odometer = System::Convert::ToUInt32(dbDispAcumDist * 100);
}


/***************************************************************************
 * LEVSensor::UpdateDisplay
 * 
 * Updates displayed simulator data on GUI
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::UpdateDisplay()
{
	this->label_P2TotDistDisplay->Text = dbDispAcumDist.ToString("N2");  // Update the accumulated distance label
	
	// the tx variables will show the raw transmitted data decoded, but not scaled into proper units
	USHORT usCurrentSpeed = LEVData->usCurrentLEVSpeed & 0x0FFF;
	this->label_StatusSpeedVal->Text = usCurrentSpeed.ToString();
	this->label_StatusOdoVal->Text = LEVData->ulOdometer.ToString();
	this->label_StatusAssistVal->Text = LEVData->ucPercentAssist.ToString();
}


/**************************************************************************
 * LEVSensor::comboBox_P1BattTemp_SelectedIndexChanged
 * 
 * Updates the user selected battery temperature setting
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::comboBox_P1BattTemp_SelectedIndexChanged(System::Object^  sender, System::EventArgs^  e)
{
	UpdateBatteryTemp();
}


/**************************************************************************
 * LEVSensor::UpdateBatteryTemp
 * 
 * Sets the Battery temperature, Page 3, Byte 3, bits 0-2
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::UpdateBatteryTemp()
{
	if (this->comboBox_P1BattTemp->Text->Equals("Unknown"))			// 000 = unknown
	{
		LEVData->ucTemperature = (LEVData->ucTemperature & 0xF8);	// clear the bits 0-2 only   
	}
	else if (this->comboBox_P1BattTemp->Text->Equals("Cold"))		// 001 = cold
	{
		LEVData->ucTemperature = (LEVData->ucTemperature & 0xF8);	// clear the bits 0-2 only    
		LEVData->ucTemperature = (LEVData->ucTemperature | 0x01);	// set bit 0 high
	}
	else if (this->comboBox_P1BattTemp->Text->Equals("Cold/Warm"))	// 010 = cold/warm
	{
		LEVData->ucTemperature = (LEVData->ucTemperature & 0xF8);	// clear the bits 0-2 only 
		LEVData->ucTemperature = (LEVData->ucTemperature | 0x02);	// set bit 1 high
	}
	else if (this->comboBox_P1BattTemp->Text->Equals("Warm"))		// 011 = warm
	{
		LEVData->ucTemperature = (LEVData->ucTemperature & 0xF8);	// clear the bits 0-2 only
		LEVData->ucTemperature = (LEVData->ucTemperature | 0x03);	// set bits 0,1 high
	}
	else if (this->comboBox_P1BattTemp->Text->Equals("Warm/Hot"))	// 100 = warm/hot
	{
		LEVData->ucTemperature = (LEVData->ucTemperature & 0xF8);	// clear the bits 0-2 only
		LEVData->ucTemperature = (LEVData->ucTemperature | 0x04);	// set bit 2 high
	}
	else if (this->comboBox_P1BattTemp->Text->Equals("Hot"))		// 101 = hot
	{
		LEVData->ucTemperature = (LEVData->ucTemperature & 0xF8);	// clear the bits 0-2 only 
		LEVData->ucTemperature = (LEVData->ucTemperature | 0x05);	// set bits 0,2 high
	}
}


/**************************************************************************
 * LEVSensor::comboBox_P1MotorTemp_SelectedIndexChanged
 * 
 * Updates the user selected battery motor setting
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::comboBox_P1MotorTemp_SelectedIndexChanged(System::Object^  sender, System::EventArgs^  e)
{
	UpdateMotorTemp();
}


/**************************************************************************
 * LEVSensor::UpdateMotorTemp
 * 
 * Sets the Battery temperature, Page 3, Byte 3, bits 4-6
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::UpdateMotorTemp()
{
	if (this->comboBox_P1MotorTemp->Text->Equals("Unknown"))			// 000 = unknown
	{
		LEVData->ucTemperature = (LEVData->ucTemperature & 0x8F);	// clear the bits 4-6 only   
	}
	else if (this->comboBox_P1MotorTemp->Text->Equals("Cold"))		// 001 = cold
	{
		LEVData->ucTemperature = (LEVData->ucTemperature & 0x8F);		// clear the bits 4-6 only      
		LEVData->ucTemperature = (LEVData->ucTemperature | (1 << 4));	// shift value up 4 to get into bits 4-6
	}
	else if (this->comboBox_P1MotorTemp->Text->Equals("Cold/Warm"))	// 010 = cold/warm
	{
		LEVData->ucTemperature = (LEVData->ucTemperature & 0x8F);		// clear the bits 4-6 only    
		LEVData->ucTemperature = (LEVData->ucTemperature | (2 << 4));	// shift value up 4 to get into bits 4-6
	}
	else if (this->comboBox_P1MotorTemp->Text->Equals("Warm"))		// 011 = warm
	{
		LEVData->ucTemperature = (LEVData->ucTemperature & 0x8F);		// clear the bits 4-6 only   
		LEVData->ucTemperature = (LEVData->ucTemperature | (3 << 4));	// shift value up 4 to get into bits 4-6
	}
	else if (this->comboBox_P1MotorTemp->Text->Equals("Warm/Hot"))	// 100 = warm/hot
	{
		LEVData->ucTemperature = (LEVData->ucTemperature & 0x8F);		// clear the bits 4-6 only   
		LEVData->ucTemperature = (LEVData->ucTemperature | (4 << 4));	// shift value up 4 to get into bits 4-6
	}
	else if (this->comboBox_P1MotorTemp->Text->Equals("Hot"))		// 101 = hot
	{
		LEVData->ucTemperature = (LEVData->ucTemperature & 0x8F);		// clear the bits 4-6 only    
		LEVData->ucTemperature = (LEVData->ucTemperature | (5 << 4));	// shift value up 4 to get into bits 4-6
	}
}


/**************************************************************************
 * LEVSensor::checkBox_P1BattOverheat_CheckedChanged
 * 
 * Sets the battery overheat alert, Page 3, Byte 3, bit 3
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::checkBox_P1BattOverheat_CheckedChanged(System::Object^  sender, System::EventArgs^  e)
{
	if (this->checkBox_P1BattOverheat->Checked == TRUE)
		LEVData->ucTemperature |= 0x08;            // set bit 3 to 1   		
	else
		LEVData->ucTemperature &= (UCHAR)~0x08;    // set bit 3 to 0
}


/**************************************************************************
 * LEVSensor::checkBox_P1MotorOverheat_CheckedChanged
 * 
 * Sets the battery overheat alert, Page 3, Byte 3, bit 7
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::checkBox_P1MotorOverheat_CheckedChanged(System::Object^  sender, System::EventArgs^  e)
{
	if (this->checkBox_P1MotorOverheat->Checked == TRUE)
		LEVData->ucTemperature |= 0x80;            // set bit 7 to 1   		
	else
		LEVData->ucTemperature &= (UCHAR)~0x80;    // set bit 7 to 0
}


/**************************************************************************
 * LEVSensor::checkBox_P1TempUnused_CheckedChanged
 * 
 * Sets the temperature to "unused"
 * Page 3, Byte 3
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::checkBox_P1TempUnused_CheckedChanged(System::Object^  sender, System::EventArgs^  e)
{
	if (this->checkBox_P1TempUnused->Checked == TRUE)
	{
		LEVData->ucTemperature = 0x00;
		comboBox_P1BattTemp->Enabled = FALSE;
		comboBox_P1MotorTemp->Enabled = FALSE;
		checkBox_P1BattOverheat->Enabled = FALSE;
		checkBox_P1MotorOverheat->Enabled = FALSE;
	}
	else
	{
		comboBox_P1BattTemp->Enabled = TRUE;
		comboBox_P1MotorTemp->Enabled = TRUE;
		checkBox_P1BattOverheat->Enabled = TRUE;
		checkBox_P1MotorOverheat->Enabled = TRUE;
		
		// recreate the byte based on UI

		UpdateMotorTemp();
		UpdateBatteryTemp();
		
		if (this->checkBox_P1MotorOverheat->Checked == TRUE)
			LEVData->ucTemperature |= 0x80;            // set bit 7 to 1   		
		else
			LEVData->ucTemperature &= (UCHAR)~0x80;    // set bit 7 to 0

		if (this->checkBox_P1BattOverheat->Checked == TRUE)
			LEVData->ucTemperature |= 0x08;            // set bit 3 to 1   		
		else
			LEVData->ucTemperature &= (UCHAR)~0x08;    // set bit 3 to 0
	}
}


/**************************************************************************
 * LEVSensor::comboBox_P1AssistLevel_SelectedIndexChanged
 * 
 * Updates the user selected Current Assist Level
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::comboBox_P1AssistLevel_SelectedIndexChanged(System::Object^  sender, System::EventArgs^  e)
{
	CheckAssistMapping();
}

/**************************************************************************
 * LEVSensor::CheckAssistMapping
 * 
 * Checks if the current Assist Level is consistent with the number of
 * supported Assist modes
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::CheckAssistMapping()
{
	// Get the number of supported Assist Modes
	UCHAR SupportedAssistModes = ((LEVData->ucSupportedTravelModes & 0x38) >> 3);
	UCHAR CurrentAssistMode = ((LEVData->ucTravelModeState & 0x38) >> 3);


	// if Assist Off is selected, set the assist level to 000
	if(this->comboBox_P1AssistLevel->Text->Equals("Assist Off"))
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);
	else if(SupportedAssistModes == 7)
		UpdateAssistModeState();
	else 
	{
		// switch number of supported assist modes
		switch(SupportedAssistModes)
		{
		case 0x01:	// 1 assist modes supported, selecting "Assist 7" acceptable
			// if anything other than "Assist Off" is selected, Send a messagebox with an error message
			if(!(this->comboBox_P1AssistLevel->Text->Equals("Assist 7")))
			{
				MessageBox::Show("The LEV supports 1 Assist Mode. Please select Assist 7 or Off");
				switch(CurrentAssistMode)
				{
				case 0x07:
					this->comboBox_P1AssistLevel->Text = "Assist 7";
					break;
				default:
					this->comboBox_P1AssistLevel->Text = "Assist Off";
					break;
				}
			}
			// if "Assist Off" was selected, it would have been caught in the above if statement
			else
				UpdateAssistModeState();
			break;
		case 0x02:	// 2 assist modes supported, selecting "Assist 3" or "Assist 7" acceptable
			// if anything other than "Assist 3" or "Assist 7" is selected, send messagebox with error message
			if(!((this->comboBox_P1AssistLevel->Text->Equals("Assist 3")) || (this->comboBox_P1AssistLevel->Text->Equals("Assist 7"))))
			{
				MessageBox::Show("The LEV supports 2 Assist Modes. Please select Assist 3, 7 or Off");
				switch(CurrentAssistMode)
				{
				case 0x03:
					this->comboBox_P1AssistLevel->Text = "Assist 3";
					break;
				case 0x07:
					this->comboBox_P1AssistLevel->Text = "Assist 7";
					break;
				default:
					this->comboBox_P1AssistLevel->Text = "Assist Off";
					break;
				}
			}
			// if "Assist Off" was selected, it would have been caught in the above if statement
			else
				UpdateAssistModeState();
			break;
		case 0x03:	// 3 Assist modes supported, selecting "Assist 2", "Assist 4" or "Assist 7" acceptable
			// if anything other than "Assist 2", "Assist 4", or "Assist 7" is selected, show messagebox with an error message
			if(!((this->comboBox_P1AssistLevel->Text->Equals("Assist 2")) || (this->comboBox_P1AssistLevel->Text->Equals("Assist 4")) || (this->comboBox_P1AssistLevel->Text->Equals("Assist 7"))))
			{
				MessageBox::Show("The LEV supports 3 Assist Modes. Please select Assist 2, 4, 7, or Off");
				switch(CurrentAssistMode)
				{
				case 0x02:
					this->comboBox_P1AssistLevel->Text = "Assist 2";
					break;
				case 0x04:
					this->comboBox_P1AssistLevel->Text = "Assist 4";
					break;
				case 0x07:
					this->comboBox_P1AssistLevel->Text = "Assist 7";
					break;
				default:
					this->comboBox_P1AssistLevel->Text = "Assist Off";
					break;
				}
			}
			// if "Assist Off" was selected, it would have been caught in the above if statement
			else
				UpdateAssistModeState();
			break;
		case 0x04:	// 4 assist modes supported, selecting "Assist 2", "Assist 4" or "Assist 6" NOT acceptable
			// if "Assist 2", "Assist 4" or "Assist 6" selected, show messagebox with error message
			if((this->comboBox_P1AssistLevel->Text->Equals("Assist 2")) || (this->comboBox_P1AssistLevel->Text->Equals("Assist 4")) || (this->comboBox_P1AssistLevel->Text->Equals("Assist 6")))
			{
				MessageBox::Show("The LEV supports 4 Assist Modes. Please select Assist 1, 3, 5, 7, or Off");
				switch(CurrentAssistMode)
				{
				case 0x01:
					this->comboBox_P1AssistLevel->Text = "Assist 1";
					break;
				case 0x03:
					this->comboBox_P1AssistLevel->Text = "Assist 3";
					break;
				case 0x05:
					this->comboBox_P1AssistLevel->Text = "Assist 5";
					break;
				case 0x07:
					this->comboBox_P1AssistLevel->Text = "Assist 7";
					break;
				default:
					this->comboBox_P1AssistLevel->Text = "Assist Off";
					break;
				}
			}
			// if "Assist Off" selected, it would have been caught in the above if statement
			else
				UpdateAssistModeState();
			break;
		case 0x05:	// 5 assist modes supported, selecting "Assist 4" or "Assist 6" NOT acceptable
			// if "Assist 4" or "Assist 6" selected, show messagebox with error message
			if((this->comboBox_P1AssistLevel->Text->Equals("Assist 4")) || (this->comboBox_P1AssistLevel->Text->Equals("Assist 6")))
			{
				MessageBox::Show("The LEV supports 5 Assist Modes. Please select Assist 1, 2, 3, 5, 7, or Off");
				switch(CurrentAssistMode)
				{
				case 0x01:
					this->comboBox_P1AssistLevel->Text = "Assist 1";
					break;
				case 0x02:
					this->comboBox_P1AssistLevel->Text = "Assist 2";
					break;
				case 0x03:
					this->comboBox_P1AssistLevel->Text = "Assist 3";
					break;
				case 0x05:
					this->comboBox_P1AssistLevel->Text = "Assist 5";
					break;
				case 0x07:
					this->comboBox_P1AssistLevel->Text = "Assist 7";
					break;
				default:
					this->comboBox_P1AssistLevel->Text = "Assist Off";
					break;
				}
			}
			// if "Assist Off" selected, it would have been caught in the above if statement
			else
				UpdateAssistModeState();
			break;
		case 0x06:	// 6 assist modes supported, selecting "Assist 6" NOT acceptable
			// if "Assist 6" selected, show messagebox with error message
			if((this->comboBox_P1AssistLevel->Text->Equals("Assist 6")))
			{
				MessageBox::Show("The LEV supports 6 Assist Modes. Please select Assist 1, 2, 3, 4, 5, 7 or Off");
				switch(CurrentAssistMode)
				{
				case 0x01:
					this->comboBox_P1AssistLevel->Text = "Assist 1";
					break;
				case 0x02:
					this->comboBox_P1AssistLevel->Text = "Assist 2";
					break;
				case 0x03:
					this->comboBox_P1AssistLevel->Text = "Assist 3";
					break;
				case 0x04:
					this->comboBox_P1AssistLevel->Text = "Assist 4";
					break;
				case 0x05:
					this->comboBox_P1AssistLevel->Text = "Assist 5";
					break;
				case 0x07:
					this->comboBox_P1AssistLevel->Text = "Assist 7";
					break;
				default:
					this->comboBox_P1AssistLevel->Text = "Assist Off";
					break;
				}
			}
			// if "Assist Off" selected, it would have been caught in the above if statement
			else
				UpdateAssistModeState();
			break;
		default:
			// set Assist mode to off on default
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);
		}
	}
}
/**************************************************************************
 * LEVSensor::UpdateAssistModeState
 * 
 * Sets the Current Assist Level, Page 1, Byte 2, bits 3-5
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::UpdateAssistModeState()
{
	if (this->comboBox_P1AssistLevel->Text->Equals("Assist 1"))				// 001 = Assist 1
	{
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);	// clear the bits 3-5 only 
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x08);	// set bit 3 high
	}
	else if (this->comboBox_P1AssistLevel->Text->Equals("Assist 2"))		// 010 = Assist 2
	{
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);	// clear the bits 3-5 only 
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x10);	// set bit 4 high
	}
	else if (this->comboBox_P1AssistLevel->Text->Equals("Assist 3"))		// 011 = Assist 3
	{
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);	// clear the bits 3-5 only 
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x18);	// set bits 3,4 high
	}
	else if (this->comboBox_P1AssistLevel->Text->Equals("Assist 4"))		// 100 = Assist 4
	{
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);	// clear the bits 3-5 only 
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x20);	// set bit 5 high
	}
	else if (this->comboBox_P1AssistLevel->Text->Equals("Assist 5"))		// 101 = Assist 5
	{
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);	// clear the bits 3-5 only 
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x28);	// set bits 5,3 high
	}
	else if (this->comboBox_P1AssistLevel->Text->Equals("Assist 6"))		// 110 = Assist 6
	{
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);	// clear the bits 3-5 only 
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x30);	// set bits 5,4 high
	}
	else if (this->comboBox_P1AssistLevel->Text->Equals("Assist 7"))		// 111 = Assist 7
	{
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);	// clear the bits 3-5 only 
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x38);	// set bits 5,4,3 high
	}
	
	
}


/**************************************************************************
 * LEVSensor::comboBox_P1RegenLevel_SelectedIndexChanged
 * 
 * Updates the user selected Current Regen Level
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::comboBox_P1RegenLevel_SelectedIndexChanged(System::Object^  sender, System::EventArgs^  e)
{
	CheckRegenMapping();
}


/**************************************************************************
 * LEVSensor::CheckRegenMapping
 * 
 * Checks if the current user selected Regen Level is consistent with the 
 * number of supported Regen modes
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::CheckRegenMapping()
{
	// Get the number of supported Regen Modes
	UCHAR SupportedRegenModes = (LEVData->ucSupportedTravelModes & 0x07);
	UCHAR CurrentRegen = (LEVData->ucTravelModeState & 0x07); 

	// If Regen Off is selected, set the regen level to 000
	if(this->comboBox_P1RegenLevel->Text->Equals("Regenerative Off"))
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
	// If the number of supported Regen Modes is 7, there is no need to check Regen Mapping
	else if(SupportedRegenModes == 7)
		UpdateRegenModeState();
	else 
	{
		// switch number of supported regen modes
		switch(SupportedRegenModes)
		{
			
		case 0x00:	// No regen modes supported, only selecting "Regen Off" is acceptable
			// if anything other than "Regen Off" is selected, Send a messagebox with an error message
			if(!(this->comboBox_P1RegenLevel->Text->Equals("Regenerative Off")))
			{
				MessageBox::Show("The LEV does not support any Regenerative Modes. Please Select Regenerative Off");
				this->comboBox_P1RegenLevel->Text = "Regenerative Off";
			}
			// if "Regen Off" was selected, it would have been caught in the above if statement
			break;
		case 0x01:	// 1 regen mode supported, selecting "Regen Off" or "Regen 7" acceptable
			// if anything other than "Regen 7" is selected, send messagebox with an error message
			if(!(this->comboBox_P1RegenLevel->Text->Equals("Regenerative 7")))
			{
				MessageBox::Show("The LEV supports 1 Regenerative Mode. Please select Regenerative 7 or Off");
				switch(CurrentRegen)
				{
				case 0x07:
					this->comboBox_P1RegenLevel->Text = "Regenerative 7";
					break;
				default:
					this->comboBox_P1RegenLevel->Text = "Regenerative Off";
					break;
				}
			}
			// update the regen mode, "Regen Off" case is caught in the above if statement
			else
				UpdateRegenModeState();
			break;
		case 0x02:	// 2 regen modes supported, selecting "Regen Off", "Regen 3" or "Regen 7" acceptable
			// if anything other than "Regen 3" or "Regen 7" is selected, send messagebox with an error message
			if(!((this->comboBox_P1RegenLevel->Text->Equals("Regenerative 3")) || (this->comboBox_P1RegenLevel->Text->Equals("Regenerative 7"))))
			{
				MessageBox::Show("The LEV supports 2 Regenerative Modes. Please select Regenerative 3, 7 or Off");
				switch(CurrentRegen)
				{
				case 0x03:
					this->comboBox_P1RegenLevel->Text = "Regenerative 3";
					break;
				case 0x07:
					this->comboBox_P1RegenLevel->Text = "Regenerative 7";
					break;
				default:
					this->comboBox_P1RegenLevel->Text = "Regenerative Off";
					break;
				}
			}
			// update the regen mode, "Regen Off" case is caught in the above if statement
			else
				UpdateRegenModeState();
			break;
		case 0x03:	// 3 regen modes supported, selecting "Regen Off", "Regen 2", "Regen 4" or "Regen 7" acceptable
			// if anything other than "Regen 2", "Regen 4", or "Regen 7" is selected, send messagebox with an error message
			if(!((this->comboBox_P1RegenLevel->Text->Equals("Regenerative 2")) || (this->comboBox_P1RegenLevel->Text->Equals("Regenerative 4")) || (this->comboBox_P1RegenLevel->Text->Equals("Regenerative 7"))))
			{
				MessageBox::Show("The LEV supports 3 Regenerative Modes. Please select Regenerative 2, 4, 7, or Off");
				switch(CurrentRegen)
				{
				case 0x02:
					this->comboBox_P1RegenLevel->Text = "Regenerative 2";
					break;
				case 0x04:
					this->comboBox_P1RegenLevel->Text = "Regenerative 4";
					break;
				case 0x07:
					this->comboBox_P1RegenLevel->Text = "Regenerative 7";
					break;
				default:
					this->comboBox_P1RegenLevel->Text = "Regenerative Off";
					break;
				}
			}
			// update the regen mode, "Regen Off" case is caught in the above else if statement
			else
				UpdateRegenModeState();
			break;
		case 0x04:	// 4 regen modes supported, selecting "Regen 2", "Regen 4", or "Regen 6" is NOT acceptable
			// if "Regen 2", "Regen 4" or "Regen 6" is selected, send messagebox with an errore message
			if((this->comboBox_P1RegenLevel->Text->Equals("Regenerative 2")) || (this->comboBox_P1RegenLevel->Text->Equals("Regenerative 4")) || (this->comboBox_P1RegenLevel->Text->Equals("Regenerative 6")))
			{
				MessageBox::Show("The LEV supports 4 Regenerative Modes. Please select Regenerative 1, 3, 5, 7, or Off");
				switch(CurrentRegen)
				{
				case 0x01:
					this->comboBox_P1RegenLevel->Text = "Regenerative 1";
					break;
				case 0x03:
					this->comboBox_P1RegenLevel->Text = "Regenerative 3";
					break;
				case 0x05:
					this->comboBox_P1RegenLevel->Text = "Regenerative 5";
					break;
				case 0x07:
					this->comboBox_P1RegenLevel->Text = "Regenerative 7";
					break;
				default:
					this->comboBox_P1RegenLevel->Text = "Regenerative Off";
					break;
				}
			}
			// update the regen mode, "Regen Off" case is caught in the above if statement
			else
				UpdateRegenModeState();
			break;
		case 0x05:	// 5 regen modes supported, selecting "Regen 4" or "Regen 6" is NOT acceptable 
			// if "Regen 4" or "Regen 6" is selected, send messagebox with an error message
			if((this->comboBox_P1RegenLevel->Text->Equals("Regenerative 4")) || (this->comboBox_P1RegenLevel->Text->Equals("Regenerative 6")))
			{
				MessageBox::Show("The LEV supports 5 Regenerative Modes. Please select Regenerative 1, 2, 3, 5, 7, or Off");
				switch(CurrentRegen)
				{
				case 0x01:
					this->comboBox_P1RegenLevel->Text = "Regenerative 1";
					break;
				case 0x02:
					this->comboBox_P1RegenLevel->Text = "Regenerative 2";
					break;
				case 0x03:
					this->comboBox_P1RegenLevel->Text = "Regenerative 3";
					break;
				case 0x05:
					this->comboBox_P1RegenLevel->Text = "Regenerative 5";
					break;
				case 0x07:
					this->comboBox_P1RegenLevel->Text = "Regenerative 7";
					break;
				default:
					this->comboBox_P1RegenLevel->Text = "Regenerative Off";
					break;
				}
			}
			// update the regen mode, "Regen Off" is caught in the above if statement
			else
				UpdateRegenModeState();
			break;
		case 0x06:	// 6 regen modes supported, selecting "Regen 6" is NOT acceptable
			// if "Regen 6" is selected, send messagebox with an error message
			if((this->comboBox_P1RegenLevel->Text->Equals("Regenerative 6")))
			{
				MessageBox::Show("The LEV supports 6 Regenerative Modes. Please select Regenerative 1, 2, 3, 4, 5, 7 or Off");
				switch(CurrentRegen)
				{
				case 0x01:
					this->comboBox_P1RegenLevel->Text = "Regenerative 1";
					break;
				case 0x02:
					this->comboBox_P1RegenLevel->Text = "Regenerative 2";
					break;
				case 0x03:
					this->comboBox_P1RegenLevel->Text = "Regenerative 3";
					break;
				case 0x04:
					this->comboBox_P1RegenLevel->Text = "Regenerative 4";
					break;
				case 0x05:
					this->comboBox_P1RegenLevel->Text = "Regenerative 5";
					break;
				case 0x07:
					this->comboBox_P1RegenLevel->Text = "Regenerative 7";
					break;
				default:
					this->comboBox_P1RegenLevel->Text = "Regenerative Off";
					break;
				}
			}
			// update the regen mode, "Regen Off"  is caught in the above if statement
			else
				UpdateRegenModeState();
			break;
		default:
			// by default set TravelMode to 0
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
		}
	}
}
/**************************************************************************
 * LEVSensor::UpdateRegenModeState
 * 
 * Sets the Current Regen Level, Page 1, Byte 2, bits 0-2
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::UpdateRegenModeState()
{
	if (this->comboBox_P1RegenLevel->Text->Equals("Regenerative Off"))		// 000 = Regen Off
	{
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);	// clear the bits 0-2 only   
	}
	else if (this->comboBox_P1RegenLevel->Text->Equals("Regenerative 1"))	// 001 = Regen 1
	{
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);	// clear the bits 0-2 only 
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x01);	// set bit 0 high
	}
	else if (this->comboBox_P1RegenLevel->Text->Equals("Regenerative 2"))	// 010 = Regen 2
	{
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);	// clear the bits 0-2 only 
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x02);	// set bit 1 high
	}
	else if (this->comboBox_P1RegenLevel->Text->Equals("Regenerative 3"))	// 011 = Regen 3
	{
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);	// clear the bits 0-2 only 
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x03);	// set bits 0,1 high
	}
	else if (this->comboBox_P1RegenLevel->Text->Equals("Regenerative 4"))	// 100 = Regen 4
	{
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);	// clear the bits 0-2 only 
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x04);	// set bit 2 high
	}
	else if (this->comboBox_P1RegenLevel->Text->Equals("Regenerative 5"))	// 101 = Regen 5
	{
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);	// clear the bits 0-2 only 
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x05);	// set bits 0,2 high
	}
	else if (this->comboBox_P1RegenLevel->Text->Equals("Regenerative 6"))	// 110 = Regen 6
	{
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);	// clear the bits 0-2 only 
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x06);	// set bits 2,1 high
	}
	else if (this->comboBox_P1RegenLevel->Text->Equals("Regenerative 7"))	// 111 = Regen 7
	{
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);	// clear the bits 0-2 only 
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x07);	// set bits 0,1,2 high
	}
}


/**************************************************************************
 * LEVSensor::checkBox_P1HighBeam_CheckedChanged
 * 
 * Toggles the bit in the system state bitfield for high/low beam, page 1, byte 3, bit 2
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::checkBox_P1HighBeam_CheckedChanged(System::Object^  sender, System::EventArgs^  e)
{
	if (this->checkBox_P1HighBeam->Checked == TRUE)
		LEVData->ucSystemState |= 0x04;           // set bit 2 to 1   		
	else
		LEVData->ucSystemState &= (UCHAR)~0x04;    // set bit 2 to 0
}


/**************************************************************************
 * LEVSensor::checkBox_P1LightOn_CheckedChanged
 * 
 * Toggles the bit in the system state bitfield for Light on/off, page 1, byte 3, bit 3
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::checkBox_P1LightOn_CheckedChanged(System::Object^  sender, System::EventArgs^  e)
{
	if (this->checkBox_P1LightOn->Checked == TRUE)
		LEVData->ucSystemState |= 0x08;           // set bit 3 to 1   		
	else
		LEVData->ucSystemState &= (UCHAR)~0x08;    // set bit 3 to 0
}


/**************************************************************************
 * LEVSensor::checkBox_P1LeftSignalOn_CheckedChanged
 * 
 * Toggles the bit in the system state bitfield for left signal on/off, page 1, byte 3, bit 1
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::checkBox_P1LeftSignalOn_CheckedChanged(System::Object^  sender, System::EventArgs^  e)
{
	if (this->checkBox_P1LeftSignalOn->Checked == TRUE)
		LEVData->ucSystemState |= 0x02;           // set bit 1 to 1   		
	else
		LEVData->ucSystemState &= (UCHAR)~0x02;    // set bit 1 to 0
}


/**************************************************************************
 * LEVSensor::checkBox_P1RightSignalOn_CheckedChanged
 * 
 * Toggles the bit in the system state bitfield for right signal on/off, page 1, byte 3, bit 0
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::checkBox_P1RightSignalOn_CheckedChanged(System::Object^  sender, System::EventArgs^  e)
{
	if (this->checkBox_P1RightSignalOn->Checked == TRUE)
		LEVData->ucSystemState |= 0x01;           // set bit 0 to 1   		
	else
		LEVData->ucSystemState &= (UCHAR)~0x01;    // set bit 0 to 0
}


/**************************************************************************
 * LEVSensor::checkBox_P1Throttle_CheckedChanged
 * 
 * Toggles the bit in the system state bitfield for right signal on/off, page 1, byte 3, bit 0
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::checkBox_P1Throttle_CheckedChanged(System::Object^  sender, System::EventArgs^  e)
{
	if (this->checkBox_P1Throttle->Checked == TRUE)
		LEVData->ucSystemState |= 0x10;           // set bit 4 to 1   		
	else
		LEVData->ucSystemState &= (UCHAR)~0x10;    // set bit 4 to 0
}


/**************************************************************************
 * LEVSensor::comboBox_P1FrontGear_SelectedIndexChanged
 * 
 * Updates the user selected Front Gear Setting
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::comboBox_P1FrontGear_SelectedIndexChanged(System::Object^  sender, System::EventArgs^  e)
{
	UpdateFrontGearState();
}


/**************************************************************************
 * LEVSensor::UpdateFrontGearState
 * 
 * Sets the Front Gear Setting, Page 1, Byte 4, bits 0-1
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::UpdateFrontGearState()
{
	if (this->comboBox_P1FrontGear->Text->Equals("none"))			// 00 = no gear
	{
		LEVData->ucGearState = (LEVData->ucGearState & 0xFC);	// clear the bits 0-1 only   
	}
	else if (this->comboBox_P1FrontGear->Text->Equals("1"))			// 01 = gear 1
	{
		LEVData->ucGearState = (LEVData->ucGearState & 0xFC);	// clear the bits 0-1 only    
		LEVData->ucGearState = (LEVData->ucGearState | 0x01);	// set bit 0 high
	}
	else if (this->comboBox_P1FrontGear->Text->Equals("2"))		// 10 = gear 2
	{
		LEVData->ucGearState = (LEVData->ucGearState & 0xFC);	// clear the bits 0-1 only 
		LEVData->ucGearState = (LEVData->ucGearState | 0x02);	// set bit 1 high
	}
	else if (this->comboBox_P1FrontGear->Text->Equals("3"))		// 11 = gear 3
	{
		LEVData->ucGearState = (LEVData->ucGearState & 0xFC);	// clear the bits 0-1 only 
		LEVData->ucGearState = (LEVData->ucGearState | 0x03);	// set bits 0,1 high
	}
}


/**************************************************************************
 * LEVSensor::comboBox_P1RearGear_SelectedIndexChanged
 * 
 * Updates the user selected Rear Gear Setting
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::comboBox_P1RearGear_SelectedIndexChanged(System::Object^  sender, System::EventArgs^  e)
{
	UpdateRearGearState();
}


/**************************************************************************
 * LEVSensor::UpdateRearGearState
 * 
 * Sets the Front Rear Setting, Page 1, Byte 4, bits 2-5
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::UpdateRearGearState()
{
	if (this->comboBox_P1RearGear->Text->Equals("none"))		// 0000 = no gear
	{
		LEVData->ucGearState = (LEVData->ucGearState & 0xC3);	// clear the bits 2-5 only   
	}
	else if (this->comboBox_P1RearGear->Text->Equals("1"))		// 0001 = gear 1
	{
		LEVData->ucGearState = (LEVData->ucGearState & 0xC3);		// clear the bits 2-5 only 
		LEVData->ucGearState = (LEVData->ucGearState | (1 << 2));	// shift value up 2 to get into bits 2-5
	}
	else if (this->comboBox_P1RearGear->Text->Equals("2"))		// 0010 = gear 2
	{
		LEVData->ucGearState = (LEVData->ucGearState & 0xC3);		// clear the bits 2-5 only 
		LEVData->ucGearState = (LEVData->ucGearState | (2 << 2));	// shift value up 2 to get into bits 2-5
	}
	else if (this->comboBox_P1RearGear->Text->Equals("3"))		// 0011 = gear 3
	{
		LEVData->ucGearState = (LEVData->ucGearState & 0xC3);		// clear the bits 2-5 only 
		LEVData->ucGearState = (LEVData->ucGearState | (3 << 2));	// shift value up 2 to get into bits 2-5
	}
	else if (this->comboBox_P1RearGear->Text->Equals("4"))		// 0100 = gear 4
	{
		LEVData->ucGearState = (LEVData->ucGearState & 0xC3);		// clear the bits 2-5 only 
		LEVData->ucGearState = (LEVData->ucGearState | (4 << 2));	// shift value up 2 to get into bits 2-5
	}
	else if (this->comboBox_P1RearGear->Text->Equals("5"))		// 0101 = gear 5
	{
		LEVData->ucGearState = (LEVData->ucGearState & 0xC3);		// clear the bits 2-5 only 
		LEVData->ucGearState = (LEVData->ucGearState | (5 << 2));	// shift value up 2 to get into bits 2-5
	}
	else if (this->comboBox_P1RearGear->Text->Equals("6"))		// 0110 = gear 6
	{
		LEVData->ucGearState = (LEVData->ucGearState & 0xC3);		// clear the bits 2-5 only 
		LEVData->ucGearState = (LEVData->ucGearState | (6 << 2));	// shift value up 2 to get into bits 2-5
	}
	else if (this->comboBox_P1RearGear->Text->Equals("7"))		// 0111 = gear 7
	{
		LEVData->ucGearState = (LEVData->ucGearState & 0xC3);		// clear the bits 2-5 only 
		LEVData->ucGearState = (LEVData->ucGearState | (7 << 2));	// shift value up 2 to get into bits 2-5
	}
	else if (this->comboBox_P1RearGear->Text->Equals("8"))		// 1000 = gear 8
	{
		LEVData->ucGearState = (LEVData->ucGearState & 0xC3);		// clear the bits 2-5 only 
		LEVData->ucGearState = (LEVData->ucGearState | (8 << 2));	// shift value up 2 to get into bits 2-5
	}
	else if (this->comboBox_P1RearGear->Text->Equals("9"))		// 1001 = gear 9 
	{
		LEVData->ucGearState = (LEVData->ucGearState & 0xC3);		// clear the bits 2-5 only 
		LEVData->ucGearState = (LEVData->ucGearState | (9 << 2));	// shift value up 2 to get into bits 2-5
	}
	else if (this->comboBox_P1RearGear->Text->Equals("10"))		// 1010 = gear 10
	{
		LEVData->ucGearState = (LEVData->ucGearState & 0xC3);		// clear the bits 2-5 only 
		LEVData->ucGearState = (LEVData->ucGearState | (10 << 2));	// shift value up 2 to get into bits 2-5
	}
	else if (this->comboBox_P1RearGear->Text->Equals("11"))		// 1011 = gear 11
	{
		LEVData->ucGearState = (LEVData->ucGearState & 0xC3);		// clear the bits 2-5 only 
		LEVData->ucGearState = (LEVData->ucGearState | (11 << 2));	// shift value up 2 to get into bits 2-5
	}
	else if (this->comboBox_P1RearGear->Text->Equals("12"))		// 1100 = gear 12
	{
		LEVData->ucGearState = (LEVData->ucGearState & 0xC3);		// clear the bits 2-5 only 
		LEVData->ucGearState = (LEVData->ucGearState | (12 << 2));	// shift value up 2 to get into bits 2-5
	}
	else if (this->comboBox_P1RearGear->Text->Equals("13"))		// 1101 = gear 13
	{
		LEVData->ucGearState = (LEVData->ucGearState & 0xC3);		// clear the bits 2-5 only 
		LEVData->ucGearState = (LEVData->ucGearState | (13 << 2));	// shift value up 2 to get into bits 2-5
	}
	else if (this->comboBox_P1RearGear->Text->Equals("14"))		// 1110 = gear 14
	{
		LEVData->ucGearState = (LEVData->ucGearState & 0xC3);		// clear the bits 2-5 only 
		LEVData->ucGearState = (LEVData->ucGearState | (14 << 2));	// shift value up 2 to get into bits 2-5
	}
	else if (this->comboBox_P1RearGear->Text->Equals("15"))		// 1111 = gear 15
	{
		LEVData->ucGearState = (LEVData->ucGearState & 0xC3);		// clear the bits 2-5 only 
		LEVData->ucGearState = (LEVData->ucGearState | (15 << 2));	// shift value up 2 to get into bits 2-5
	}
}


/**************************************************************************
 * LEVSensor::checkBox_P1GearsExist_CheckedChanged
 * 
 * Toggles the bit in the gear state bitfield for selecting whether gears exist or not
 * Page 1, Byte 4, bit 7
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::checkBox_P1GearsExist_CheckedChanged(System::Object^  sender, System::EventArgs^  e)
{
	if (this->checkBox_P1GearsExist->Checked == TRUE)
		LEVData->ucGearState |= 0x80;           // set bit 7 to 1   		
	else
		LEVData->ucGearState &= (UCHAR)~0x80;    // set bit 7 to 0
}


/**************************************************************************
 * LEVSensor::checkBox_P1ManualGears_CheckedChanged
 * 
 * Toggles the bit in the gear state bitfield for selecting whether gear control is auto or manual
 * Page 1, Byte 4, bit 6
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::checkBox_P1ManualGears_CheckedChanged(System::Object^  sender, System::EventArgs^  e)
{
	if (this->checkBox_P1ManualGears->Checked == TRUE)
		LEVData->ucGearState |= 0x40;           // set bit 6 to 1   		
	else
		LEVData->ucGearState &= (UCHAR)~0x40;    // set bit 6 to 0
}


/**************************************************************************
 * LEVSensor::radioButton_CheckedChanged
 * 
 * Single event handler for all of the radio buttons on the error page
 * Changes the error field to the appropriate value, Pgae 1, Byte 5
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::radioButton_CheckedChanged(System::Object^  sender, System::EventArgs^  e)
{
	if (radioButton_P1NoError->Checked == TRUE)
    {
        numericUpDown_P1CustomError->Enabled = FALSE;
		LEVData->ucErrorMessage = 0x00;
    }
    else if (radioButton_P1BatteryError->Checked == TRUE)
    {
		numericUpDown_P1CustomError->Enabled = FALSE;
        LEVData->ucErrorMessage = 0x01;
    }
	else if (radioButton_P1TrainError->Checked == TRUE)
    {
		numericUpDown_P1CustomError->Enabled = FALSE;
        LEVData->ucErrorMessage = 0x02;
    }
	else if (radioButton_P1EndLife->Checked == TRUE)
    {
		numericUpDown_P1CustomError->Enabled = FALSE;
        LEVData->ucErrorMessage = 0x03;
    }
	else if (radioButton_P1Overheat->Checked == TRUE)
    {
		numericUpDown_P1CustomError->Enabled = FALSE;
        LEVData->ucErrorMessage = 0x04;
    }
	else if (radioButton_P1CustomError->Checked == TRUE)
    {
		numericUpDown_P1CustomError->Enabled = TRUE;
        LEVData->ucErrorMessage = System::Convert::ToByte(this->numericUpDown_P1CustomError->Value);
    }
}


/**************************************************************************
 * LEVSensor::numericUpDown_P1CustomError_ValueChanged
 * 
 * Page 1, Byte 5, Selects a custom error code to use. UI locks the range
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::numericUpDown_P1CustomError_ValueChanged(System::Object^  sender, System::EventArgs^  e)
{
	LEVData->ucErrorMessage = (System::Convert::ToByte(this->numericUpDown_P1CustomError->Value)); 
}


/**************************************************************************
 * LEVSensor::numericUpDown_P1Speed_ValueChanged
 * 
 * Page 1, Byte 6 and 7. Changes to the user selected LEV speed
 * This value is shared by page 1 and page 2, so both must be changed
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::numericUpDown_P1Speed_ValueChanged(System::Object^  sender, System::EventArgs^  e)
{
	// UI locks the range to valid numbers only
	LEVData->usCurrentLEVSpeed = System::Convert::ToUInt16(this->numericUpDown_P1Speed->Value * 10); 
	LEVData->usCurrentLEVSpeed |= 0xF000;
	LEVData->usSpeed = System::Convert::ToUInt16(this->numericUpDown_P1Speed->Value * 10);
	LEVData->usSpeed |= 0xF000;
	
	// update the Page 2 UI (note the other event handler fires if they are diffent)
	numericUpDown_P2Speed->Value = numericUpDown_P1Speed->Value;
}


/**************************************************************************
 * LEVSensor::numericUpDown_P2Speed_ValueChanged
 * 
 * Page 2, Byte 6 and 7. Changes to the user selected LEV speed
 * This value is shared by page 1 and page 2, so both must be changed
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::numericUpDown_P2Speed_ValueChanged(System::Object^  sender, System::EventArgs^  e)
{
	// UI locks the range to valid numbers only
	LEVData->usCurrentLEVSpeed = System::Convert::ToUInt16(this->numericUpDown_P2Speed->Value * 10); 
	LEVData->usCurrentLEVSpeed |= 0xF000;
	LEVData->usSpeed = System::Convert::ToUInt16(this->numericUpDown_P1Speed->Value * 10);
	LEVData->usSpeed |= 0xF000;

	// update the Page 1 UI (note the other event handler fires if they are diffent)
	numericUpDown_P1Speed->Value = numericUpDown_P2Speed->Value;

	//MessageBox::Show("usCurrentLEVSpeed " + LEVData->usCurrentLEVSpeed.ToString(), "Speed Error", MessageBoxButtons::OK,MessageBoxIcon::Error, MessageBoxDefaultButton::Button1);
	//MessageBox::Show("ulNewSpeed " + ulNewSpeed.ToString(), "Speed Error", MessageBoxButtons::OK,MessageBoxIcon::Error, MessageBoxDefaultButton::Button1);
}


/**************************************************************************
 * LEVSensor::button_P2UpdateDist_Click
 * 
 * Validates and updates cumulative distance, from user input (GUI)
 * 
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::button_P2UpdateDist_Click(System::Object^  sender, System::EventArgs^  e) 
{
	this->label_P2UpdateError->Visible = false;
	//convert and catch failed conversions
	try{
		//LEVData->ulOdometer = (ULONG) System::Convert::ToInt32(this->textBox_P2TotDistChange->Text);
		//dbDispAcumDist = System::Convert::ToDouble(this->textBox_P2TotDistChange->Text);

		LEVData->ulOdometer = System::Convert::ToInt32(this->numericUpDown_P2Distance->Value);
		LEVData->ulP34Odometer = System::Convert::ToInt32(this->numericUpDown_P2Distance->Value);
		dbDispAcumDist = System::Convert::ToDouble(numericUpDown_P2Distance->Value);
		this->label_P2TotDistDisplay->Text =  System::Convert::ToString(this->numericUpDown_P2Distance->Value);
	}
	catch(...){
		this->label_P2UpdateError->Text = "Error: Dist";
		this->label_P2UpdateError->Visible = true;
	}
}


/**************************************************************************
 * LEVSensor::numericUpDown_P2Range_ValueChanged
 * 
 * Page 3, Byte 6,7. Changes the user selected battery range, range locked by UI
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::numericUpDown_P2Range_ValueChanged(System::Object^  sender, System::EventArgs^  e)
{
	LEVData->usRemainingRange = (System::Convert::ToUInt16(this->numericUpDown_P2Range->Value)); 
	LEVData->usRemainingRange |= 0xF000;
}


/**************************************************************************
 * LEVSensor::checkBox_P2RangeUnused_CheckedChanged
 * 
 * Sets the temperature to "unused"
 * Page 3, Byte 3
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::checkBox_P2RangeUnused_CheckedChanged(System::Object^  sender, System::EventArgs^  e)
{
	if (this->checkBox_P2RangeUnused->Checked == TRUE)
	{
		LEVData->usRemainingRange = 0xF000;
		numericUpDown_P2Range->Enabled = FALSE;
	}
	else
	{
		numericUpDown_P2Range->Enabled = TRUE;
		LEVData->usRemainingRange = (System::Convert::ToUInt16(this->numericUpDown_P2Range->Value)); 
		LEVData->usRemainingRange |= 0xF000;
	}
}


/**************************************************************************
 * LEVSensor::numericUpDown_P3PercentAssist_ValueChanged
 * 
 * Page 2, Byte 2. Changes the user selected % assist (0-100%)
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::numericUpDown_P3PercentAssist_ValueChanged(System::Object^  sender, System::EventArgs^  e)
{
	LEVData->ucPercentAssist = (System::Convert::ToByte(this->numericUpDown_P3PercentAssist->Value)); 
}


/**************************************************************************
 * LEVSensor::numericUpDown_P3Charge_ValueChanged
 * 
 * Page 3, Byte 4. Changes the user selected battery charge, range locked by UI
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::numericUpDown_P3Charge_ValueChanged(System::Object^  sender, System::EventArgs^  e)
{
	// preserve bit 7
	if ((LEVData->ucBatteryCharge & 0x80) != 0)		// check if bit 7 high
	{
		LEVData->ucBatteryCharge = (System::Convert::ToByte(this->numericUpDown_P3Charge->Value)); 
		LEVData->ucBatteryCharge |= 0x80;           // set bit 7 to 1   
	}
	else
		LEVData->ucBatteryCharge = (System::Convert::ToByte(this->numericUpDown_P3Charge->Value)); 
}


/**************************************************************************
 * LEVSensor::checkBox_P3BattEmpty_CheckedChanged
 * 
 * Sets the temperature to "unused"
 * Page 3, Byte 3
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::checkBox_P3BattEmpty_CheckedChanged(System::Object^  sender, System::EventArgs^  e)
{
	if (this->checkBox_P3BattEmpty->Checked == TRUE)
		LEVData->ucBatteryCharge |= 0x80;           // set bit 7 to 1   		
	else
		LEVData->ucBatteryCharge &= (UCHAR)~0x80;    // set bit 7 to 0
}


/**************************************************************************
 * LEVSensor::numericUpDown_P4Voltage_ValueChanged
 * 
 * Page 3, Byte 5. Changes the user selected battery voltage, range locked by UI
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::numericUpDown_P4Voltage_ValueChanged(System::Object^  sender, System::EventArgs^  e)
{
	LEVData->ucBatteryVoltage = (System::Convert::ToByte(this->numericUpDown_P4Voltage->Value)); 
}


/**************************************************************************
 * LEVSensor::checkBox_P4VoltUnused_CheckedChanged
 * 
 * Sets the temperature to "unused"
 * Page 3, Byte 3
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::checkBox_P4VoltUnused_CheckedChanged(System::Object^  sender, System::EventArgs^  e)
{
	if (this->checkBox_P4VoltUnused->Checked == TRUE)
	{
		LEVData->ucBatteryVoltage = 0x00;
		numericUpDown_P4Voltage->Enabled = FALSE;
	}
	else
	{
		numericUpDown_P4Voltage->Enabled = TRUE;
		LEVData->ucBatteryVoltage = (System::Convert::ToByte(this->numericUpDown_P4Voltage->Value)); 
	}
}


/**************************************************************************
 * LEVSensor::numericUpDown_P4DistanceOnCharge_ValueChanged
 * 
 * Page 4, Bytes 6-7. Changes the distance on charge value, range locked by UI
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::numericUpDown_P4DistanceOnCharge_ValueChanged(System::Object^  sender, System::EventArgs^  e)
{
	LEVData->usDistanceOnCharge = System::Convert::ToUInt16(this->numericUpDown_P4DistanceOnCharge->Value * 10); 
}


/**************************************************************************
 * LEVSensor::checkBox_P4DistanceOnChargeUnused_CheckChanged
 * 
 * Page 4, Bytes 6-7 Updates if Distance on Current Charge is used or note
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::checkBox_P4DistanceOnChargeUnused_CheckedChanged(System::Object^  sender, System::EventArgs^ e)
{
	if(this->checkBox_P4DistanceOnChargeUnused->Checked == TRUE)
	{
		this->numericUpDown_P4DistanceOnCharge->Enabled = FALSE;
		LEVData->usDistanceOnCharge &= 0x0000;
	}
	else
	{
		this->numericUpDown_P4DistanceOnCharge->Enabled = TRUE;
		LEVData->usDistanceOnCharge = System::Convert::ToUInt16(this->numericUpDown_P4DistanceOnCharge->Value * 10);
	}
}
/**************************************************************************
 * LEVSensor::numericUpDown_P4FuelConsumption_ValueChanged
 * 
 * Page 4, Bytes 3.5-4 Changes the fuel consumption value, range locked by UI
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::numericUpDown_P4FuelConsumption_ValueChanged(System::Object^  sender, System::EventArgs^  e)
{
	LEVData->usFuelConsumption = System::Convert::ToUInt16(this->numericUpDown_P4FuelConsumption->Value * 10); 
	LEVData->usP34FuelConsumption = System::Convert::ToUInt16(this->numericUpDown_P4FuelConsumption->Value * 10);
}


/**************************************************************************
 * LEVSensor::checkBox_P4FuelConsumptionUnused_CheckChanged
 * 
 * Page 4, Bytes 3.5-4 Updates if Fuel Consumption is used or not
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::checkBox_P4FuelConsumptionUnused_CheckedChanged(System::Object^  sender, System::EventArgs^  e)
{
	if(this->checkBox_P4FuelConsumptionUnused->Checked == TRUE)
	{
		this->numericUpDown_P4FuelConsumption->Enabled = FALSE;
		LEVData->usFuelConsumption &= 0xF000;
		LEVData->usP34FuelConsumption &= 0xF000;
	}
	else
	{
		this->numericUpDown_P4FuelConsumption->Enabled = TRUE;
		LEVData->usFuelConsumption |= System::Convert::ToUInt16(this->numericUpDown_P4FuelConsumption->Value * 10); 
		LEVData->usP34FuelConsumption |= System::Convert::ToUInt16(this->numericUpDown_P4FuelConsumption->Value * 10);
	}
}
/**************************************************************************
 * LEVSensor::numericUpDown_P4ChargeCycle_ValueChanged
 * 
 * Page 4, Bytes 2-3.5 Changes the number of Charge cycles, range is locked by UI
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::numericUpDown_P4ChargeCycle_ValueChanged(System::Object^  sender, System::EventArgs^  e)
{
	LEVData->usChargeCycleCount = System::Convert::ToUInt16(this->numericUpDown_P4ChargeCycle->Value); 
}


/**************************************************************************
 * LEVSensor::checkBox_P4ChargeCycleUnused_CheckedChanged
 * 
 * Page 4, Byte 2-3.5 Updates if Charge Cycle is Used or Not
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::checkBox_P4ChargeCycleUnused_CheckedChanged(System::Object^  sender, System::EventArgs^  e)
{
	if(this->checkBox_P4ChargeCycleUnused->Checked == TRUE)
	{
		this->numericUpDown_P4ChargeCycle->Enabled = FALSE;
		LEVData->usChargeCycleCount &= 0xF000;
	}
	else
	{
		this->numericUpDown_P4ChargeCycle->Enabled = TRUE;
		LEVData->usChargeCycleCount |= System::Convert::ToUInt16(this->numericUpDown_P4ChargeCycle->Value);
	}
}
/**************************************************************************
 * LEVSensor::numericUpDwn_P5AssistModes_ValueChanged
 * 
 * Page 1, Byte 1, Bits 3-5. Changes the number of Assist Modes Supported (0-7)
 * in the Travel Modes Supported Byte
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::numericUpDwn_P5AssistModes_ValueChanged(System::Object^  sender, System::EventArgs^  e)
{
	UCHAR tempHolder;

	// shift the number to the left 3 times to put into bits 3-5
	tempHolder = (System::Convert::ToByte(this->numericUpDwn_P5AssistModes->Value) << 3); 
	LEVData->ucSupportedTravelModes = (LEVData->ucSupportedTravelModes & 0xC7);	      // first need to clear the bits 3-5 only
	LEVData->ucSupportedTravelModes = (LEVData->ucSupportedTravelModes | tempHolder); // then combine with what is already be present in the full variable
	UpdateP1Assist();

}


/**************************************************************************
 * LEVSensor::UpdateP1Assist
 * 
 * Handles Assist Mode mapping when the number of supported assist modes is changed
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::UpdateP1Assist()
{
	// get the number of assist modes currently in Page 5
	UCHAR SupportedAssist = ((LEVData->ucSupportedTravelModes & 0x38) >> 3);
	UCHAR CurrentAssist = ((LEVData->ucTravelModeState & 0x38) >> 3);

	if(SupportedAssist == 1)	// LEV supports 1 AssistMode
	{
		switch(CurrentAssist)
		{
		case 0:	// "Assist Off" is common to all mapping, nothing needs to be done 
			break;
		default:	// if the current Assist mode is not Off, change the page 16 data to Assist mode 7 and change the combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x38);
			this->comboBox_P1AssistLevel->Text = "Assist 7";
			break;
		}
	}
	else if(SupportedAssist == 2)	// LEV supports 2 AssistModes
	{
		switch(CurrentAssist)
		{
		case 1:
		case 2:	
		case 3:	// if Assist mode is 1, 2, or 3 ensure page 16 data is Assist mode 3 and change combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x18);
			this->comboBox_P1AssistLevel->Text = "Assist 3";
			break;
		case 4:
		case 5:
		case 6:	
		case 7:	// if Assist mode is 4, 5, 6, or 7 ensure page 16 data is Assist mode 7 and change combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x38);
			this->comboBox_P1AssistLevel->Text = "Assist 7";
			break;
		default:	// "Assist Off" is common to all mapping, nothing needs to be done
			break;
		}
	}
	else if(SupportedAssist == 3)	// LEV supports 3 Assist Modes
	{
		switch(CurrentAssist)
		{
		case 1:	
		case 2:	// if Assist mode is 1, or 2, ensure page 16 data is Assist mode 2 and change combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x10);
			this->comboBox_P1AssistLevel->Text = "Assist 2";
			break;
		case 3:	
		case 4:	// if the current Assist mode is 3 or 4, ensure page 16 data is Assist mode 4 and change combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x20);
			this->comboBox_P1AssistLevel->Text = "Assist 4";
			break;
		case 5:
		case 6:	
		case 7:	// if the current Assist mode is 5, 6, or 7, ensure page 16 data is Assist mode 7 and change combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x38);
			this->comboBox_P1AssistLevel->Text = "Assist 7";
			break;
		default:	// "Assist Off" is common to all mapping, nothing needs to be done
			break;
		}
	}
	else if(SupportedAssist == 4)	// LEV supports 4 Assist Modes
	{
		switch(CurrentAssist)
		{
		case 1:	// if the current Assist mode is 1, ensure page 16 data is Assist mode 1 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x08);
			break;
		case 2:	
		case 3:	// if the current Assist mode is 2 or 3, ensure page 16 data is Assist mode 3 and change combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x18);
			this->comboBox_P1AssistLevel->Text = "Assist 3";
			break;
		case 4:	
		case 5:	// if the current Assist mode is 4 or 5, ensure page 16 data is Assist mode 5 and change combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x28);
			this->comboBox_P1AssistLevel->Text = "Assist 5";
			break;
		case 6:	
		case 7:	// if the current Assist mode is 6 or 7, ensure page 16 data is Assist mode 7 and change combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x38);
			this->comboBox_P1AssistLevel->Text = "Assist 7";
			break;
		default:	// "Assist Off" is common to all mapping, nothing needs to be done
			break;
		}
	}
	else if(SupportedAssist== 5)	// LEV supports 5 Assist Modes
	{
		switch(CurrentAssist)
		{
		case 1:	// if the current Assist mode is 1, ensure page 16 data is Assist mode 1 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x08);
			break;
		case 2:	// if the current Assist mode is 2, ensure page 16 data is Assist mode 2 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x10);
			break;
		case 3:	// if the current Assist mode is 3, ensure page 16 data is Assist mode 3 
			LEVData->ucP16TravelMode = (LEVData->ucP16TravelMode & 0xC7);
			LEVData->ucP16TravelMode = (LEVData->ucP16TravelMode | 0x18);
			break;
		case 4:
		case 5:	// if the current Assist mode is 4 or 5, ensure page 16 data is Assist mode 5 and change combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x28);
			this->comboBox_P1AssistLevel->Text = "Assist 5";
			break;
		case 6:
		case 7:	// if the current Assist mode is 6 or 7, ensure page 16 data is Assist mode 7 and change combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x38);
			this->comboBox_P1AssistLevel->Text = "Assist 7";
			break;
		default:	// "Assist Off" is common to call mapping, nothing needs to be done
			break;
		}
	}
	else if(SupportedAssist == 6)	// LEV supports 6 Assist Modes
	{
		switch(CurrentAssist)
		{
		case 1:	// if the currentAssistmode is 1, ensure page 16 data is Assist mode 1 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x08);
			break;
		case 2:	// if the current Assist mode is 2, ensure page 16 data is Assist mode 2 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x10);
			break;
		case 3:	// if the current Assist mode is 3, ensure page 16 data is Assist mode 3 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x18);
			break;
		case 4: // if the current Assist mode is 4, ensure page 16 data is Assist mode 4 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x20);
			break;
		case 5: // if the current Assist mode is 5, ensure page 16 data is Assist mode 5 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x28);
			break;
		case 6:
		case 7:	// if the current Assist mode is 6 or 7, ensure page 16 data is Assist mode 7 and change combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x38);
			this->comboBox_P1AssistLevel->Text = "Assist 7";
			break;
		default:	// "Assist Off" is common to all mapping, nothing needs to be done
			break;
		}
	}
}
/**************************************************************************
 * LEVSensor::numericUpDown_P5RegenModes_ValueChanged
 * 
 * Page 1, Byte 1, Bits 0-2. Changes the number of Regen Modes Supported (0-7)
 * in the Travel Modes Supported Byte
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::numericUpDown_P5RegenModes_ValueChanged(System::Object^  sender, System::EventArgs^  e)
{
	UCHAR tempHolder;
	
	tempHolder = System::Convert::ToByte(this->numericUpDown_P5RegenModes->Value); 
	LEVData->ucSupportedTravelModes = (LEVData->ucSupportedTravelModes & 0xF8);	      // first need to clear the bits 0-2 only
	LEVData->ucSupportedTravelModes = (LEVData->ucSupportedTravelModes | tempHolder); // then combine with what is already be present in the full variable
	UpdateP1Regen();
}


/**************************************************************************
 * LEVSensor::UpdateP1Regen
 * 
 * Handles Regen Mode mapping when the number of supported regen modes is changed
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::UpdateP1Regen()
{
	// get the number of Regen modes currently in Page 5
	UCHAR SupportedRegen = LEVData->ucSupportedTravelModes & 0x07;
	UCHAR CurrentRegen = LEVData->ucTravelModeState & 0x07;

	if(SupportedRegen == 0)
	{	// if the LEV doesn't support Regen Modes, set Page 16 data to regen mode 0 and update the combobox
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
		this->comboBox_P1RegenLevel->Text = "Regenerative Off";
	}
	else if(SupportedRegen == 1)	// LEV supports 1 Regen Mode
	{
		switch(CurrentRegen)
		{
		case 0:	// "Regenerative Off" is common to all mapping, nothing needs to be done 
			break;
		default:	// if the current regen mode is not Off, change the page 16 data to regen mode 7 and change the combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x07);
			this->comboBox_P1RegenLevel->Text = "Regenerative 7";
			break;
		}
	}
	else if(SupportedRegen == 2)	// LEV supports 2 Regen Modes
	{
		switch(CurrentRegen)
		{
		case 1:
		case 2:	
		case 3:	// if regen mode is 1, 2, or 3 ensure page 16 data is regen mode 3 and change combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x03);
			this->comboBox_P1RegenLevel->Text = "Regenerative 3";
			break;
		case 4:
		case 5:
		case 6:	
		case 7:	// if regen mode is 4, 5, 6, or 7 ensure page 16 data is regen mode 7 and change combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x07);
			this->comboBox_P1RegenLevel->Text = "Regenerative 7";
			break;
		default:	// "Regenerative Off" is common to all mapping, nothing needs to be done
			break;
		}
	}
	else if(SupportedRegen == 3)	// LEV supports 3 Regen Modes
	{
		switch(CurrentRegen)
		{
		case 1:	
		case 2:	// if regen mode is 1, or 2, ensure page 16 data is regen mode 2 and change combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x02);
			this->comboBox_P1RegenLevel->Text = "Regenerative 2";
			break;
		case 3:	
		case 4:	// if the current regen mode is 3 or 4, ensure page 16 data is regen mode 4 and change combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x04);
			this->comboBox_P1RegenLevel->Text = "Regenerative 4";
			break;
		case 5:
		case 6:	
		case 7:	// if the current regen mode is 5, 6, or 7, ensure page 16 data is regen mode 7 and change combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x07);
			this->comboBox_P1RegenLevel->Text = "Regenerative 7";
			break;
		default:	// "Regenerative Off" is common to all mapping, nothing needs to be done
			break;
		}
	}
	else if(SupportedRegen == 4)	// LEV supports 4 Regen Modes
	{
		switch(CurrentRegen)
		{
		case 1:	// if the current regen mode is 1, ensure page 16 data is regen mode 1 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x01);
			break;
		case 2:	
		case 3:	// if the current regen mode is 2 or 3, ensure page 16 data is regen mode 3 and change combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x03);
			this->comboBox_P1RegenLevel->Text = "Regenerative 3";
			break;
		case 4:	
		case 5:	// if the current regen mode is 4 or 5, ensure page 16 data is regen mode 5 and change combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x05);
			this->comboBox_P1RegenLevel->Text = "Regenerative 5";
			break;
		case 6:	
		case 7:	// if the current regen mode is 6 or 7, ensure page 16 data is regen mode 7 and change combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x07);
			this->comboBox_P1RegenLevel->Text = "Regenerative 7";
			break;
		default:	// "Regenerative Off" is common to all mapping, nothing needs to be done
			break;
		}
	}
	else if(SupportedRegen == 5)	// LEV supports 5 Regen Modes
	{
		switch(CurrentRegen)
		{
		case 1:	// if the current regen mode is 1, ensure page 16 data is regen mode 1 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x01);
			break;
		case 2:	// if the current regen mode is 2, ensure page 16 data is regen mode 2 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x02);
			break;
		case 3:	// if the current regen mode is 3, ensure page 16 data is regen mode 3 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x03);
			break;
		case 4:
		case 5:	// if the current regen mode is 4 or 5, ensure page 16 data is regen mode 5 and change combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x05);
			this->comboBox_P1RegenLevel->Text = "Regenerative 5";
			break;
		case 6:
		case 7:	// if the current regen mode is 6 or 7, ensure page 16 data is regen mode 7 and change combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x07);
			this->comboBox_P1RegenLevel->Text = "Regenerative 7";
			break;
		default:	// "Regenerative Off" is common to call mapping, nothing needs to be done
			break;
		}
	}
	else if(SupportedRegen == 6)	// LEV supports 6 Regen Modes
	{
		switch(CurrentRegen)
		{
		case 1:	// if the current regen mode is 1, ensure page 16 data is regen mode 1 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x01);
			break;
		case 2:	// if the current regen mode is 2, ensure page 16 data is regen mode 2 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x02);
			break;
		case 3:	// if the current regen mode is 3, ensure page 16 data is regen mode 3 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x03);
			break;
		case 4: // if the current regen mode is 4, ensure page 16 data is regen mode 4 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x04);
			break;
		case 5: // if the current regen mode is 5, ensure page 16 data is regen mode 5 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x05);
			break;
		case 6:
		case 7:	// if the current regen mode is 6 or 7, ensure page 16 data is regen mode 7 and change combobox index
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x07);
			this->comboBox_P1RegenLevel->Text = "Regenerative 7";
			break;
		default:	// "Regenerative Off" is common to all mapping, nothing needs to be done
			break;
		}
	}
}
/**************************************************************************
 * LEVSensor::numericUpDown_P5Circum_ValueChanged
 * 
 * Page 5, Bytes 3-4.5 Changes the wheel circumference value, range is locked by UI
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::numericUpDown_P5Circum_ValueChanged(System::Object^  sender, System::EventArgs^  e)
{
	LEVData->usWheelCircumference = System::Convert::ToUInt16(this->numericUpDown_P5Circum->Value); 
	LEVData->usWheelCircumference |= 0xF000;
}


/**************************************************************************
 * LEVSensor::checkBox_P16Supported_CheckedChanged
 * 
 * Selects whether incoming P16s should be processed or not
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::checkBox_P16Supported_CheckedChanged(System::Object^  sender, System::EventArgs^  e)
{
	if (this->checkBox_P16Supported->Checked == TRUE)
		bPage16Supported = TRUE;
	else
		bPage16Supported = FALSE;
}


/**************************************************************************
 * LEVSensor::button_CommonUpdate_Click
 * 
 * Adjusts the global pages 80 and 81 via the GUI
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::button_CommonUpdate_Click(System::Object^  sender, System::EventArgs^  e)
{
	// required common pages
	//commonData->ulSerialNum = System::Convert::ToUInt32(this->textBox_SerialNum->Text);
	//commonData->ucSwVersion = System::Convert::ToByte(this->textBox_SwVersion->Text);
	//commonData->ucHwVersion = System::Convert::ToByte(this->textBox_HwVersion->Text);
	//commonData->usMfgID = System::Convert::ToUInt16(this->textBox_MfgID->Text);
	//commonData->usModelNum = System::Convert::ToUInt16(this->textBox_ModelNum->Text);

	label_ErrorCommon->Visible = false;
	label_ErrorCommon->Text = "Error: ";
	// Convert and catch failed conversions
	try{
		commonDataSensor->usMfgID = System::Convert::ToUInt16(this->textBox_MfgID->Text);
	}
	catch(...){
		label_ErrorCommon->Text = System::String::Concat(label_ErrorCommon->Text, " MFID");
		label_ErrorCommon->Visible = true;
	}
	try{
		if(this->checkBox_NoSerial->Checked)
			commonDataSensor->ulSerialNum = 0xFFFFFFFF;
		else
			commonDataSensor->ulSerialNum = System::Convert::ToUInt32(this->textBox_SerialNum->Text);
	}
	catch(...){
		label_ErrorCommon->Text = System::String::Concat(label_ErrorCommon->Text, " Ser#");
		label_ErrorCommon->Visible = true;
	}
	try{
		commonDataSensor->ucHwVersion = System::Convert::ToByte(this->textBox_HwVersion->Text);
	}
	catch(...){
		label_ErrorCommon->Text = System::String::Concat(label_ErrorCommon->Text, " HWVr");
		label_ErrorCommon->Visible = true;
	}
	try{
		commonDataSensor->ucSwVersion = System::Convert::ToByte(this->textBox_SwVersion->Text);
	}
	catch(...){
		label_ErrorCommon->Text = System::String::Concat(label_ErrorCommon->Text, " SWVr");
		label_ErrorCommon->Visible = true;
	}
	try{
		commonDataSensor->usModelNum = System::Convert::ToUInt16(this->textBox_ModelNum->Text);
	}
	catch(...){
		label_ErrorCommon->Text = System::String::Concat(label_ErrorCommon->Text, " Mdl#");
		label_ErrorCommon->Visible = true;
	}
}



/**************************************************************************
 * LEVSensor::checkBox_P5WheelCircum_CheckChanged
 * 
 * Page 5 Bytes 3-4.5 Updates if Wheel Circumference is used or not
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::checkBox_P5WheelCircum_CheckedChanged(System::Object^  sender, System::EventArgs^  e)
{
	if(this->checkBox_P5WheelCircum->Checked == TRUE)
	{
		this->numericUpDown_P5Circum->Enabled = FALSE;
		LEVData->usWheelCircumference &= 0xF000;		// set wheel circumference to 0 to indicate unused
	}
	else
	{
		this->numericUpDown_P5Circum->Enabled = TRUE;
		LEVData->usWheelCircumference = System::Convert::ToUInt16(this->numericUpDown_P5Circum->Value); 
		LEVData->usWheelCircumference |= 0xF000;
	}
}
//MessageBox::Show("ucSystemState " + LEVData->ucSystemState.ToString(), "Speed Error", MessageBoxButtons::OK,MessageBoxIcon::Error, MessageBoxDefaultButton::Button1);
//MessageBox::Show("ucSupportedTravelModes " + LEVData->ucSupportedTravelModes.ToString() + " tempHolder" + tempHolder.ToString(), "Speed Error", MessageBoxButtons::OK,MessageBoxIcon::Error, MessageBoxDefaultButton::Button1);
	//LEVData->ucSupportedTravelModes = System::Convert::ToByte(this->numericUpDwn_P5AssistModes->Value);

/**************************************************************************
 * LEVSensor::MapAssistModes	
 * 
 * Adjusts the Assist Mode received in page 16 depending on the number of Modes supported on page 5
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::MapAssistModes()
{
	//Get the number of Assist Modes requested/set by Display in Page 16
	UCHAR AssistMode = ((LEVData->ucP16TravelMode & 0x38) >> 3);
	//Get the number of Assist Modes Supported by the LEV
	UCHAR SupportedModes = ((LEVData->ucSupportedTravelModes & 0x38) >> 3);

	if(SupportedModes == 1)	// LEV supports 1 Assist Mode
	{
		if(AssistMode)	// map requested assist modes 1,2,3,4,5,6,7 to LEV assist mode 7
		{
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);	// clear bits 3-5
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x38);	// set bits 3-5 high (xx 111 xxx)
		}
		else	// No mapping required for incoming assist mode 0
			LEVData->ucTravelModeState &= 0xC7;	// set bits 3-5 low (xx 000 xxx) 
	}
	else if(SupportedModes == 2)	// LEV supports 2 Assist Modes
	{
		if(AssistMode == 1 || AssistMode == 2 || AssistMode == 3)	// map requested assist modes 1,2,3 to LEV assist mode 3
		{
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);	// clear bits 3-5
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x18);	// set bits 3-4 high (xx 011 xxx)
		}
		else if(AssistMode == 0)	// No mapping required for incoming assist mode 0
		{
			LEVData->ucTravelModeState &= 0xC7;	// set bits 3-5 low (xx 000 xxx) 
		}
		else	// map requested assist modes 4,5,6,7 to LEV assist mode 7
		{
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);	// clear bits 3-5 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x38);	// set bits 3-5 high (xx 111 xxx)
		}
	}
	else if(SupportedModes == 3)	// LEV supports 3 Assist Modes
	{
		if(AssistMode == 1 || AssistMode == 2)	// map requeseted assist modes 1,2 to LEV assist mode 2
		{
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);	// clear bits 3-5 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x10);	// set bit 4 high (xx 010 xxx)
		}
		else if(AssistMode == 3 || AssistMode == 4)	// map requested assist modes 3,4 to LEV assist mode 4
		{			
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);	// clear bits 3-5 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x20);	// set bit 5 high (xx 100 xxx)
		}
		else if(AssistMode == 0)	// No mapping required for incoming assist mode 0
		{
			LEVData->ucTravelModeState &= 0xC7;	// set bits 3-5 low (xx 000 xxx) 
		}
		else	// map requested assist modes 5,6,7 to LEV assist mode 7
		{		
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);	// clear bits 3-5 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x38);	// set bits 3-5 high (xx 111 xxx)
		}
	}
	else if(SupportedModes == 4)	// LEV supports 4 Assist Modes
	{
		if(AssistMode == 0 || AssistMode == 1)	// No mapping required for incoming assist modes 0, 1
		{
			LEVData->ucTravelModeState &= 0xC7;	// set bits 3-5 low (xx 000 xxx)

			if(AssistMode == 1)	// if assist mode 1
				LEVData->ucTravelModeState |= 0x08;	// set bit 3 high (xx 001 xxx)
		}
		else if(AssistMode == 2 || AssistMode == 3)	// map incoming assist modes 2,3 to LEV assist mode 3
		{
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);	// clear bits 3-5 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x18);	// set bits 3-4 high (xx 011 xxx)
		}
		else if(AssistMode == 4 || AssistMode == 5) // map incoming assist modes 4, 5 to LEV assist mode 5
		{
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);	// clear bits 3-5 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x28);	// set bits 3 and 5 high (xx 101 xxx)
		}
		else	// map incoming assist modes 6,7 to LEV assist mode 7
		{
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);	// clear bits 3-5 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x38);	// set bits 3-5 high (xx 111 xxx)
		}
	}
	else if(SupportedModes == 5)	// LEV supports 5 Assist Modes
	{
		if(AssistMode == 0 || AssistMode == 1 || AssistMode == 2 || AssistMode == 3)	// No mapping required for incoming assist modes 0,1,2,3
		{
			LEVData->ucTravelModeState &= 0xC7;	// set bits 3-5 low (xx 000 xxx)

			if(AssistMode == 1)	// if assist mode 1
				LEVData->ucTravelModeState |= 0x08;	// set bit 3 high (xx 001 xxx)
			else if(AssistMode == 2)	// if assist mode 2
				LEVData->ucTravelModeState |= 0x10;	// set bit 4 high (xx 010 xxx)
			else if(AssistMode == 3)	// if assist mode 3
				LEVData->ucTravelModeState |= 0x18;	// set bits 3-4 high (xx 011 xxx) 
		}
		else if(AssistMode == 4 || AssistMode == 5)	// map incoming assist modes 4,5 to LEV assist mode 5
		{
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);	// clear bits 3-5 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x28);	// set bits 3 and 5 high (xx 101 xxx)
		}
		else	// map incoming assist modes 6,7 to LEV assist mode 7
		{
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);	// clear bits 3-5 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x38);	// set bits 3-5 high (xx 111 xxx)
		}
	}
	else if(SupportedModes == 6)	// LEV supports 6 Assist Modes
	{
		if(AssistMode == 0 || AssistMode == 1 || AssistMode == 2 || AssistMode == 3 || AssistMode == 4 || AssistMode == 5)	// No mapping required for incoming assist modes 0,1,2,3,4,5
		{
			LEVData->ucTravelModeState &= 0xC7;	// set bits 3-5 low (xx 000 xxx)

			if(AssistMode == 1)	// if assist mode 1
				LEVData->ucTravelModeState |= 0x08;	// set bit 3 high (xx 001 xxx)
			else if(AssistMode == 2)	// if assist mode 2
				LEVData->ucTravelModeState |= 0x10;	// set bit 4 high (xx 010 xxx)
			else if(AssistMode == 3)	// if assist mode 3
				LEVData->ucTravelModeState |= 0x18;	// set bits 3-4 high (xx 011 xxx) 
			else if(AssistMode == 4)	// if assist mode 4
				LEVData->ucTravelModeState |= 0x20;	// set bit 5 high (xx 100 xxx)
			else if(AssistMode == 5)	// if assist mode 5
				LEVData->ucTravelModeState |= 0x28;	// set bits 3 and 5 high (xx 101 xxx)
		}
		else	// map incoming assist modes 6,7 to assist mode 7
		{
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xC7);	// clear bits 3-5 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x38);	// set bits 3-5 high (xx 111 xxx)
		}
	}
	else
	{
			LEVData->ucTravelModeState &= 0xC7;	// set bits 3-5 low (xx 000 xxx)

			if(AssistMode == 1)	// if assist mode 1
				LEVData->ucTravelModeState |= 0x08;	// set bit 3 high (xx 001 xxx)
			else if(AssistMode == 2)	// if assist mode 2
				LEVData->ucTravelModeState |= 0x10;	// set bit 4 high (xx 010 xxx)
			else if(AssistMode == 3)	// if assist mode 3
				LEVData->ucTravelModeState |= 0x18;	// set bits 3-4 high (xx 011 xxx) 
			else if(AssistMode == 4)	// if assist mode 4
				LEVData->ucTravelModeState |= 0x20;	// set bit 5 high (xx 100 xxx)
			else if(AssistMode == 5)	// if assist mode 5
				LEVData->ucTravelModeState |= 0x28;	// set bits 3 and 5 high (xx 101 xxx)
			else if(AssistMode == 6)	// if assist mode 6
				LEVData->ucTravelModeState |= 0x30; // set bits 4 and 5 high (xx 110 xxx)
			else if(AssistMode == 7)	// if assist mode 7
				LEVData->ucTravelModeState |= 0x38;	// set bits 3-5 high (xx 111 xxx)
	}
}

/**************************************************************************
 * LEVSensor::MapRegenModes	
 * 
 * Adjusts the Regen Mode received in page 16 depending on the number of Modes supported on page 5
 *
 * returns: N/A
 *
 **************************************************************************/
void LEVSensor::MapRegenModes()
{
	//Get the number of Regen Modes requested/set by Display in Page 16
	UCHAR RegenMode = (LEVData->ucP16TravelMode & 0x07);
	//Get the number of Regen Modes Supported by the LEV
	UCHAR SupportedModes = LEVData->ucSupportedTravelModes & 0x07;
	if(SupportedModes == 0)	// No Regen Modes are Supported 
	{
		LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);	// All incoming modes map to 0
	}
	else if(SupportedModes == 1)	// LEV supports 1 Regen Mode
	{
		if(RegenMode)	// map requested regen modes 1,2,3,4,5,6,7 to regen mode 7
		{
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);	// clear bits 0-2
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x07);	// set bits 0-2 high ( xx xxx 111)
		}
		else	// No mapping required for incoming assist mode 0
			LEVData->ucTravelModeState = LEVData->ucP16TravelMode;		// these match exactly in this case 
	}
	else if(SupportedModes == 2)	// LEV supports 2 Regen Modes
	{
		if(RegenMode == 1 || RegenMode == 2 || RegenMode == 3)	// map requested regen modes 1,2,3 to LEV regen mode 3
		{
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);	// clear bits 0-2
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x03);	// set bits 0-1 high (xx xxx 011)
		}
		else if(RegenMode == 0)	// No mapping required for incoming regen mode 0
		{
			LEVData->ucTravelModeState = LEVData->ucP16TravelMode;	// these match exactly in this case
		}
		else	// map requested regen modes 4,5,6,7 to LEV regen mode 7
		{
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);	// clear bits 0-2 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x07);	// set bits 0-2 high (xx xxx 111)
		}
	}
	else if(SupportedModes == 3)	// LEV supports 3 Regen Modes
	{
		if(RegenMode == 1 || RegenMode == 2)	// map requeseted regen modes 1,2 to LEV regen mode 2
		{
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);	// clear bits 0-2 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x02);	// set bit 1 high (xx xxx 010)
		}
		else if(RegenMode == 3 || RegenMode == 4)	// map requested regen modes 3,4 to LEV regen mode 4
		{			
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);	// clear bits 0-2 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x04);	// set bit 2 high (xx xxx 100)
		}
		else if(RegenMode == 0)	// No mapping required for incoming regen mode 0
		{
			LEVData->ucTravelModeState = LEVData->ucP16TravelMode;	//these match exactly in this case
		}
		else	// map requested regen modes 5,6,7 to LEV regen mode 7
		{		
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);	// clear bits 0-2 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x07);	// set bits 0-2 high (xx xxx 111)
		}
	}
	else if(SupportedModes == 4)	// LEV supports 4 Regen Modes
	{
		if(RegenMode == 0 || RegenMode == 1)	// No mapping required for incoming regen modes 0, 1
		{
			LEVData->ucTravelModeState &= 0xF8;	// set bits 0-2 low (xx xxx 000)
			if(RegenMode == 1)	// if regen mode 1
				LEVData->ucTravelModeState |= 0x01;	// set bit 0 high (xx xxx 001)
		}
		else if(RegenMode == 2 || RegenMode == 3)	// map incoming regen modes 2,3 to LEV regen mode 3
		{
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);	// clear bits 0-2 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x03);	// set bits 0-1 high (xx xxx 011)
		}
		else if(RegenMode == 4 || RegenMode == 5) // map incoming regen modes 4, 5 to LEV regen mode 5
		{
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);	// clear bits 0-2 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x05);	// set bits 0 and 2 high (xx xxx 101)
		}
		else	// map incoming regen modes 6,7 to LEV regen mode 7
		{
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);	// clear bits 0-2 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x07);	// set bits 0-2 high (xx xxx 111)
		}
	}
	else if(SupportedModes == 5)	// LEV supports 5 Regen Modes
	{
		if(RegenMode == 0 || RegenMode == 1 || RegenMode == 2 || RegenMode == 3)	// No mapping required for incoming regen modes 0,1,2,3
		{
			LEVData->ucTravelModeState &= 0xF8;	// set bits 0-2 low (xx xxx 000)
			if(RegenMode == 1)	// if regen mode 1
				LEVData->ucTravelModeState |= 0x01;	// set bit 0 high (xx xxx 001)
			else if(RegenMode == 2)	// if regen mode 2
				LEVData->ucTravelModeState |= 0x02;	// set bit 1 high (xx xxx 010)
			else if(RegenMode == 3)	// if regen mode 3
				LEVData->ucTravelModeState |= 0x03;	// set bits 0-1 high (xx xxx 011) 
		}
		else if(RegenMode == 4 || RegenMode == 5)	// map incoming regen modes 4,5 to LEV regen mode 5
		{
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);	// clear bits 0-2 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x05);	// set bits 0 and 2 high (xx xxx 101)
		}
		else	// map incoming regen modes 6,7 to LEV regen mode 7
		{
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);	// clear bits 0-2 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x07);	// set bits 0-2 high (xx xxx 111)
		}
	}
	else if(SupportedModes == 6)	// LEV supports 6 Regen Modes
	{
		if(RegenMode == 0 || RegenMode == 1 || RegenMode == 2 || RegenMode == 3 || RegenMode == 4 || RegenMode == 5)	// No mapping required for incoming regen modes 0,1,2,3,4,5
		{
			LEVData->ucTravelModeState &= 0xF8;	// set bits 0-2 low (xx xxx 000)
			if(RegenMode == 1)	// if regen mode 1
				LEVData->ucTravelModeState |= 0x01;	// set bit 0 high (xx xxx 001)
			else if(RegenMode == 2)	// if regen mode 2
				LEVData->ucTravelModeState |= 0x02;	// set bit 1 high (xx xxx 010)
			else if(RegenMode == 3)	// if regen mode 3
				LEVData->ucTravelModeState |= 0x03;	// set bits 0-1 high (xx xxx 011) 
			else if(RegenMode == 4)	// if regen mode 4
				LEVData->ucTravelModeState |= 0x04;	// set bit 2 high (xx xxx 100)
			else if(RegenMode == 5)	// if regen mode 5
				LEVData->ucTravelModeState |= 0x05;	// set bits 0 and 2 high (xx xxx 101)
		}
		else	// map incoming regen modes 6,7 to regen mode 7
		{
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState & 0xF8);	// clear bits 0-2 
			LEVData->ucTravelModeState = (LEVData->ucTravelModeState | 0x07);	// set bits 0-2 high (xx xxx 111)
		}
	}
	else
	{
			LEVData->ucTravelModeState &= 0xF8;	// set bits 0-2 low (xx xxx 000)
			if(RegenMode == 1)	// if regen mode 1
				LEVData->ucTravelModeState |= 0x01;	// set bit 0 high (xx xxx 001)
			else if(RegenMode == 2)	// if regen mode 2
				LEVData->ucTravelModeState |= 0x02;	// set bit 1 high (xx xxx 010)
			else if(RegenMode == 3)	// if regen mode 3
				LEVData->ucTravelModeState |= 0x03;	// set bits 0-1 high (xx xxx 011) 
			else if(RegenMode == 4)	// if regen mode 4
				LEVData->ucTravelModeState |= 0x04;	// set bit 2 high (xx xxx 100)
			else if(RegenMode == 5)	// if regen mode 5
				LEVData->ucTravelModeState |= 0x05;	// set bits 0 and 2 high (xx xxx 101)
			else if(RegenMode == 6)	// if regen mode 6
				LEVData->ucTravelModeState |= 0x06; // set bits 1 and 2 high (xx xxx 110)
			else if(RegenMode == 7)	// if regen mode 7
				LEVData->ucTravelModeState |= 0x07;	// set bits 0-2 high (xx xxx 111)
	}
}

void LEVSensor::checkBox_UsePage34_CheckedChanged(System::Object ^sender, System::EventArgs ^e)
{
	if(this->checkBox_UsePage34->Checked)
		bTxPage34 = TRUE;
	else
		bTxPage34 = FALSE;
}
void LEVSensor::checkBox_NoSerial_CheckedChanged(System::Object ^sender, System::EventArgs ^e)
{
	if(this->checkBox_NoSerial->Checked)
		this->textBox_SerialNum->Enabled = false;
	else
		this->textBox_SerialNum->Enabled = true;
}